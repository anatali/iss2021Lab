package disi.builder

import java.io.File
import java.io.FileOutputStream
import java.io.OutputStreamWriter
import alice.tuprolog.*

object genUtils {
	fun test() {
		println("Hello from Utils.kt")
	}

fun genFileName( dir: String,  packageName: String,  name: String,  suffix:String ) : String {
   val sysName  = packageName.replace(".", "/")
   var fName    = ""
   var afterDot = ""
	 if( suffix.length > 0  ) afterDot = "." + suffix
	 if( sysName.length > 0 ) fName   = dir+"/"+sysName + "/" + name + afterDot
	 else fName   = dir+"/"+ name + afterDot
     //println(" +++ generate " + fName)
	 return fName
}
/*
 genFileDir
*/	
 fun genFileDir( dir: String,  packageName: String,  name: String,  suffix:String ,  contents: String){
	val fName    = genFileName(dir, packageName, name, suffix )
	val fa       = java.io.File( fName )
	fa.writeText(contents)	  
}
	
	
	fun copyFile(dir: String,  packageName: String,  name: String,  suffix:String){
		val sourcefName    = genFileName(dir, packageName, name, suffix )
		val fsource        = java.io.File( sourcefName )
		println( sourcefName )
		val contents = fsource.readText()
		
		val destfName      = genFileName("./src-gen",  "", name, suffix )
		println( destfName )
		val fdest          = java.io.File( destfName )
		fdest.writeText(contents)
	}	

	
	fun strRepToList( lr: String ) : List<String>{
		return lr.replace("[","").replace("]","").split(",")
	}
}//Object genUtils




object generator{
	
    val pengine     = Prolog() 
	val outSrcDir   = "./src" //"./src-gen"
	val packagelogo = "it/unibo"
	var msgdriven   = true
	
	fun genFilePathName(fName: String) : String{
		  return "$outSrcDir/$packagelogo/$fName"
	}

	fun genSysRules(){
		genUtils.genFileDir( outSrcDir,  "",  "sysRules" , "pl", builtin.sysRules )
	}
 

/*
 Generate the gradle build file
*/
	fun genGradleBuild( sysName: String ){
		genUtils.genFileDir( "../",  "",  "build" , "gradle", builtin.genGradleRules(sysName) )		
	}
	
		
/*
 Generate the code for the contexts
*/
	fun genCtxMainContent(dirName : String, modelFileName: String ) : String{
		val packageName = dirName.replace("$outSrcDir/","").replace("/",".")
		return """
/* Generated by AN DISI Unibo */
package $packageName
import it.unibo.kactor.QakContext
import it.unibo.kactor.sysUtil
import kotlinx.coroutines.runBlocking

fun main() = runBlocking {
	QakContext.createContexts( "localhost", this, "$modelFileName.pl", "sysRules.pl" )
}
"""
	}				
	  fun genMainCtxFile( ctxName: String, content: String ) {
	      try {
			  //generate a new directory
			    val dirName = genFilePathName(ctxName)
				val folder  = File(dirName)
		        folder.mkdirs()
			    val mainfName = "$dirName/Main_${ctxName}.kt"
			    println( "generator | genMainCtxFile mainfName=$mainfName"  )
		        val mainf     = java.io.File( mainfName )
			    if( mainf.exists() ) return
		        mainf.writeText( content )		//writeText creates the file
			    println("generator | done $mainfName")  
	      }
	      catch (e: Exception) {
	         e.printStackTrace()
	      }
	  } 

	fun genCtxMain(modelFileName : String ) : String{
		val sol = pengine.solve("context(NAME,HOST,PROTOCOL,PORT)." )
		if(  sol.isSuccess  ) {
			val ctxName = sol.getVarValue("NAME").toString()
			val ctxHost = sol.getVarValue("HOST").toString()
			//val ctxPort = sol.getVarValue("PORT").toString()
			println("ctxName=${ctxName} ctxHost=${ctxHost}")
			val content = genCtxMainContent( genFilePathName(ctxName) , modelFileName )
			genMainCtxFile(ctxName,content)
			return ctxName
		}
 		else{ println("generator | ctx not found"); return "" }
	}

/*
 Generate the code for the actors
*/
	fun genActorMsgDrivenCodeContent( actorName: String) : String{
		val packageName =  "$packagelogo/$actorName".replace("/",".") 
		return """
/* Actor msg-driven Generated by AN DISI Unibo */
package $packageName
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.actor
import kotlinx.coroutines.channels.SendChannel

var senderActor   : SendChannel<String>?  = null
var receiverActor : SendChannel<String>?  = null
val cpus = Runtime.getRuntime().availableProcessors(); 

fun curThread() : String { 
	return "thread=${Thread.currentThread().name} / nthreads=${Thread.activeCount()}" 
}
               
fun startReceiver( scope : CoroutineScope ){
	receiverActor = scope.actor<String> {   
		println("receiverActor STARTS")
		var msg = channel.receive()
		while( msg != "end" ){ 	//message-driven
			println("receiverActor receives "+ msg)
			msg = channel.receive()
		}
		println("receiverActor ENDS")
	}
}
 
fun startSender( scope : CoroutineScope){
	senderActor = scope.actor {  
		//actor is a coroutine builder (dual of produce)
		println("senderActor   STARTS")
 		receiverActor!!.send("Hello1")
		delay(250)
 		receiverActor!!.send("Hello2")
		delay(250)
		receiverActor!!.send("end")
		println("senderActor   ENDS")
 	}
} 

@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi

fun main() = runBlocking{
    println("BEGINS CPU=" + cpus  )
 	startReceiver( this )
	startSender( this )
    println("ENDS " + curThread() )
}
"""
	}
	fun genActorCodeContent( actorName: String) : String{
		val packageName =  "$packagelogo/$actorName".replace("/",".") 
		return """
 /* Actor msg-based Generated by AN DISI Unibo */ 
package $packageName
import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class $actorName(name: String, scope: CoroutineScope) : ActorBasicFsm( name, scope ){
	override fun getInitialState() : String{
		return "init"
	}
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi			
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		return {
				state("init") {
					action {
						println("$actorName | STARTS")
						//TODO 
					}
					transition( edgeName="goto",targetState="waitinput", cond=doswitch() )	 
				}
 				state("waitinput") {
					action {
					}
					transition(edgeName="t01",targetState="endOfWork",cond=whenEvent("end"))
					transition(edgeName="t02",targetState="endOfWork",cond=whenTimeout("local_tout_${actorName}_waitinput"))   
				}			
				state("endOfWork") { 
					action { 
						println("${actorName} BYE")
						terminate(0)
					}
				}	 			
			}
 
		}
}
"""		
	}
	
	fun genCodeActorFile( filePathName: String, actorName : String ){
		println( "generator | genCodeActorFile actorName=$actorName filePathName=$filePathName")
			  //generate a new directory
			    val dirName = genFilePathName(actorName)
				val folder  = File(dirName)
		        folder.mkdirs()
		val actorfName = "$dirName/${actorName}.kt"
		println( "generator | genCodeActorFile actorfName=$actorfName"  )
 		val actorf     = java.io.File( actorfName )
		if( actorf.exists() ) return
		
		if( msgdriven ) genActorMsgDrivenCodeContent( actorName )
		else genActorCodeContent( actorName )
		 
		val content    = genActorMsgDrivenCodeContent( actorName )
		actorf.writeText( content )		 
		println("generator | done $actorName")  		
	}
	
	fun genActorsCode(ctxName : String ){
		val sol = pengine.solve("getActorNames(ACTORS,$ctxName)." )
		if(  sol.isSuccess  ) {
			val actorNames     = sol.getVarValue("ACTORS") //List
			val actorNamesList = genUtils.strRepToList(actorNames.toString())  
			actorNamesList.forEach{ v -> genCodeActorFile( genFilePathName(v), v) } 			
		}else println("generator | genActorsCode ERROR")
	}

	
/*
Generate the Kotlin code given a system model written in Prolog
*/				
	fun genCodeFromModel(modelFileName : String){
		println("generator | START")
		genSysRules()
	    genGradleBuild( modelFileName )
	
		pengine.solve("consult('$modelFileName.pl')." )  
		pengine.solve("consult( '$outSrcDir/sysRules.pl' )." )
		val sol = pengine.solve("system(SYSNAME,BEHAVIOUR)." )
		if(  sol.isSuccess  ) {
			val behaviour = sol.getVarValue("BEHAVIOUR").toString()
			msgdriven     = (behaviour == "msgdriven")
		}
		val ctxName = genCtxMain( modelFileName )
		genActorsCode( ctxName )
		println("generator | END")
	}
	

	
}//Object generator

	fun main() {	//args: Array<String>?
		//Utils.test()
		val path = System.getProperty("user.dir")
		println("path=:$path"  );
		
		generator.genCodeFromModel("demo0")

	}