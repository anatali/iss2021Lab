//package disi.builder

import java.io.File
import java.io.FileOutputStream
import java.io.OutputStreamWriter
import alice.tuprolog.*
//import disi.builder.builtin

object generator{

	val pengine     = Prolog()
	//val outSrcDir   = "C:\\Didattica2018Work\\iss2021Lab\\testBuilder\\src-gen" //   "./app/src"  ../src-gen
	val outSrcDir   =  System.getProperty("user.dir")+"/src"
	val packagelogo = "it/unibo"
	var msgdriven   = false

	fun genFilePathName(fName: String) : String{
		return "$outSrcDir/$packagelogo/$fName"
	}

	fun genSysRules(){	//WE GENERATE A LOCAL COPY (for our generation ) AND THE GLOBAL ONE (for the user appl)
		genUtils.genFileDir( outSrcDir,  "",  "sysRules" , "pl", builtin.sysRules )
		genUtils.genFileDir( "./",  "",  "sysRules" , "pl", builtin.sysRules )
	}


	/*
     Generate the gradle build file
    */
	fun genGradleBuild( sysName: String ){
		genUtils.genFileDir( "./",  "",  "build" , "gradle", builtin.genGradleRules(sysName) )
	}


	/*
     Generate the code for the contexts
    */
	fun genCtxMainContent(dirName : String, modelFileName: String ) : String{
		val packageName = dirName.replace("$outSrcDir/","").replace("/",".")
		return """
/* Generated by AN DISI Unibo */
package $packageName
import it.unibo.kactor.QakContext
import it.unibo.kactor.sysUtil
import kotlinx.coroutines.runBlocking

fun main() = runBlocking {
	QakContext.createContexts( "localhost", this, "$modelFileName.pl", "sysRules.pl" )
}
"""
	}
	fun genMainCtxFile( ctxName: String, content: String ) {
		try {
			//generate a new directory
			val dirName = genFilePathName(ctxName)
			genUtils.genDirectory(dirName)
			val mainfName = "$dirName/Main_${ctxName}.kt"
			println( "generator | genMainCtxFile mainfName=$mainfName"  )
			val mainf     = java.io.File( mainfName )
			if( mainf.exists() ) return
			mainf.writeText( content )		//writeText creates the file
			println("generator | done $mainfName")
		}
		catch (e: Exception) {
			e.printStackTrace()
		}
	}

	fun getCtxName() : String {
		val sol = pengine.solve("context(NAME,HOST,PROTOCOL,PORT)." )
		if(  sol.isSuccess  ) {
			val ctxName = sol.getVarValue("NAME").toString()
			val ctxHost = sol.getVarValue("HOST").toString()
			//val ctxPort = sol.getVarValue("PORT").toString()
			println("ctxName=${ctxName} ctxHost=${ctxHost}")
 			return ctxName
		}
		else{ throw Exception("generator | ctx not found") }
	}

	fun getCtxNames() : List<String>{
		val sol = pengine.solve("getCtxNames(CTXNAMES)." )
		if(  sol.isSuccess  ) {
			val ctxNames = sol.getVarValue("CTXNAMES") 	//List
			val ctxNamesList = genUtils.strRepToList(ctxNames.toString())
			return ctxNamesList
		}else throw Exception("")
	}

	fun genCtxMain( ctxName : String, modelFileName : String ){
		val content = genCtxMainContent( genFilePathName(ctxName) , modelFileName )
		genMainCtxFile(ctxName,content)
	}

	/*
     Generate the code for the actors
    */
	fun genActorMsgDrivenCodeContent( actorName: String) : String{
		val packageName =  "$packagelogo/$actorName".replace("/",".")
		return """
/* Actor msg-driven Generated by AN DISI Unibo */
package $packageName
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.actor
import kotlinx.coroutines.channels.SendChannel

var senderActor   : SendChannel<String>?  = null
var receiverActor : SendChannel<String>?  = null
val cpus = Runtime.getRuntime().availableProcessors(); 

fun curThread() : String { 
	return "thread=${Thread.currentThread().name} / nthreads=${Thread.activeCount()}" 
}
               
fun startReceiver( scope : CoroutineScope ){
	receiverActor = scope.actor<String> {   
		println("receiverActor STARTS")
		var msg = channel.receive()
		while( msg != "end" ){ 	//message-driven
			println("receiverActor receives "+ msg)
			msg = channel.receive()
		}
		println("receiverActor ENDS")
	}
}
 
fun startSender( scope : CoroutineScope){
	senderActor = scope.actor {  
		//actor is a coroutine builder (dual of produce)
		println("senderActor   STARTS")
 		receiverActor!!.send("Hello1")
		delay(250)
 		receiverActor!!.send("Hello2")
		delay(250)
		receiverActor!!.send("end")
		println("senderActor   ENDS")
 	}
} 

@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi

fun main() = runBlocking{
    println("BEGINS CPU=" + cpus  )
 	startReceiver( this )
	startSender( this )
    println("ENDS " + curThread() )
}
"""
	}
	fun genActorCodeContent( actorName: String) : String{
		val packageName =  "$packagelogo/$actorName".replace("/",".")
		return """
 /* Actor msg-based Generated by AN DISI Unibo */ 
package $packageName
import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class $actorName(name: String, scope: CoroutineScope) : ActorBasicFsm( name, scope ){
	override fun getInitialState() : String{
		return "init"
	}
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi			
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		return {
				state("init") {
					action {
						println("$actorName | STARTS")
						//TODO 
					}
					transition( edgeName="goto",targetState="waitinput", cond=doswitch() )	 
				}
 				state("waitinput") {
					action {
					}
					transition(edgeName="t01",targetState="endOfWork",cond=whenEvent("end"))
					transition(edgeName="t02",targetState="endOfWork",cond=whenTimeout("local_tout_${actorName}_waitinput"))   
				}			
				state("endOfWork") { 
					action { 
						println("${actorName} BYE")
						terminate(0)
					}
				}	 			
			}
 
		}
}
"""
	}

	fun genCodeActorFile( filePathName: String, actorName : String ){
		println( "generator | genCodeActorFile actorName=$actorName filePathName=$filePathName")
		//generate a new directory
		val dirName = genFilePathName(actorName)
		genUtils.genDirectory(dirName)
		/*
		val folder  = File(dirName)
		folder.mkdirs()*/
		val actorfName = "$dirName/${actorName}.kt"
		val actorf     = java.io.File( actorfName )
		if( actorf.exists() ) return
		println( "generator | genCodeActorFile actorfName=$actorfName"  )
		var content = "todo"
		if( msgdriven ) content    = genActorMsgDrivenCodeContent( actorName )
		else content    = genActorCodeContent( actorName )
		actorf.writeText( content )
		//println("generator | done msgdriven=$msgdriven genCodeActorFile for $actorName")
	}

	fun genActorsCode( ctxName : String ){
		val sol = pengine.solve("getActorNames(ACTORS,$ctxName)." )
		if(  sol.isSuccess  ) {
			val actorNames     = sol.getVarValue("ACTORS") //List
			val actorNamesList = genUtils.strRepToList(actorNames.toString())
			actorNamesList.forEach{ v -> genCodeActorFile( genFilePathName(v), v) }
		}else println("generator | genActorsCode ERROR")
	}

	/*
	Generate the code for all the actors in the given context
	 */
	fun genTheContextCode( ctxName : String, modelFileName : String ) {
		genCtxMain( ctxName, modelFileName )
		//GENERATE THE SKELETON CODE OF THE MSG-BASED QAK ACTORS
		genActorsCode( ctxName )
	}

	/*
    Generate the Kotlin code given a system model written in Prolog
    */
	fun genCodeFromModel(modelFileName : String){
 		val path = System.getProperty("user.dir")
		println("generator | START path=:$path"  );
	//GENERATE THE OUTPUT DIRECTORY, if it does not exist
		val dirName = genFilePathName(outSrcDir)
		genUtils.genDirectory(dirName)

	//GENERATE THE GRADLE BUILD FILE
		genGradleBuild( modelFileName )
	//GENERATE THE SYSTEM RULES (written in Prolog)
		genSysRules()	//genera sysRules.pl che poi VIENE USATO

	//LOAD THE MODEL IN THE LOCAL KB
		pengine.solve("consult('$modelFileName.pl')." )
	//LOAD THE SYSTEM RULES	IN THE LOCAL KB
		pengine.solve("consult( '$outSrcDir/sysRules.pl' )." )
	//GET THE ACTOR BEHAVIOUR MODEL (msgdriven or  msgbased)
		val sol = pengine.solve("system(SYSNAME,BEHAVIOUR)." )
		if(  sol.isSuccess  ) {
			val behaviour = sol.getVarValue("BEHAVIOUR").toString()
			msgdriven     = (behaviour == "msgdriven")
			println("generator | genCodeFromModel msgdriven=$behaviour")
		}
		/*
		For a msg-driven actor system we must have just ONE context
		 */
		if(  msgdriven ){  //GENERATE THE SKELETON CODE OF THE MSG-DRIVEN KOTLIN ACTORS
			val ctxName = getCtxName()
  			genActorsCode( ctxName )
		}else{
		/*
		For a msg-based (qak) actor system we might have N>1 contexts
		*/
			val ctxNamesList = getCtxNames() //List<String>
			ctxNamesList.forEach{ ctxName -> genTheContextCode(  ctxName, modelFileName ) }
		}
		println("generator | END")
	}



}//Object generator

	fun main() {	//args: Array<String>?
		//Utils.test()
		val path = System.getProperty("user.dir")
		println("path=:$path"  );
		
		generator.genCodeFromModel("demo0")

	}